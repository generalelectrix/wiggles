{"version":3,"sources":["../../parser.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCQ;AAAA,eACG;AAAA,qCAKW;AAAA;AAAA;AAAA;;AAIF;AAAA,4DAAS,6BAA6B,4BAA7B,oBAAT;AAAA;;AAJE;AAAA;AAAA,wDAEI;AAAA;AAAA;AAAA;AAAS,6BAFb;AAAA;AAAA;AAAA;AAAI;AAAA,yBAAJ;AAAA;AAAA;AAAA;AAAI;AAAA,qBAAJ,MACE;AAAA;AAAA;AAAA;AAAS;AADX;;AAAA;AAAI,aALf,MAEK;AAAA;AAAS;AAOkF,SAVnG,eAAc,WAAQ,oBAAR,EAAoC,mBAAjB,4BAAiB,CAApC,CAAd;AAUmG;;AAWzF;AAAA,qCAKF;AAAA,gBAAG,uBAAH,EACI;AAAA,kDAAK,WAAM,+CAAN,kBAAL;AAAmD,aADvD,MAGI;AAAA,oDAAO,kCAAkC,kCAAzC;AAAsE;AAAA,SARxE,MAEF;AAAA,gDAAO,8CAAP;AAAsD;AAFhD;;AA4BR;AAAA,qCAKI;AAAA;;AAAA,6CAKF;AAAA,oDAAO,uEAAP;AAAoD,aALlD,MAEF;AAAA,kDAAK,WAAQ,+CAAR,kBAAL,EAA2C,yBAA3C;AAA0D;AAFjC,SAL3B,MAEF;AAAA,gDAAO,+CAAP;AAAuD;AAFjD;;AAoBG;AAAA;;AAAgB;AAAA;AAAA;;AAAhB;AAAA;AAAA;AAAyB;;AAUzB;AAAA;;AAAqB;AAAA;AAAA;;AAArB;AAAA;AAAA;AAA+B;;AAmBrC;AAAA,yCAAyC;AAAA;AAAA,SAAzC,EADH,uBACG;AAAsE;;AAgB7E;AACU;AAAA;AAAA;AAAA,gDAKI;AAAA;;AAAA,sDAKF;AAAA;AAAa,yBALX,MAEF;AAAA;AAAuC;AAFd,qBAL3B,MAEF;AAAA;AAAoD;AAF3C,iBAAP;AAAA;AAAA;;AAYV;AAAiB;;AAaX;AAAA;;AAAA,sCAKF;AAAA;AAAA;AAAA,yDAAe,UAAf;AAAyB,SALvB,MAEF;AAAA;AAAS;AAFW","file":"parser.js","sourcesContent":["namespace Elmish\n\n(* This port of the Elm library helps you turn URLs into nicely structured data.\nIt is designed to be used with `elm-lang/navigation` to help folks create\nsingle-page applications (SPAs) where you manage browser navigation yourself.\n*)\n\nmodule UrlParser = \n\n    type Chunks = { seen : string list; rest : string list }\n\n    (* A `Parser` is a way of turning a URL like `/blog/42/cat-herding-techniques`\n    into structured data.\n    The two type variables can be a bit tricky to understand. I think the best way\n    to proceed is to just start using it. You can go far if you just assume it will\n    do the intuitive thing.\n    **Note:** If you *insist* on digging deeper, I recommend figuring out the type\n    of `i32 </> i32` based on the type signatures for `i32` and `</>`. You may be\n    able to just know based on intuition, but instead, you should figure out\n    exactly how every type variable gets unified. It is pretty cool! From there,\n    maybe check out the implementation a bit.\n    *)\n    type Parser<'formatter,'result> = Chunks -> 'formatter -> Result<Chunks*'result, string>\n\n\n    (* Actually run a parser. For example, if we want to handle blog posts with\n    an ID number and a name, we might write something like this:\n        blog = s \"blog\" </> i32 </> str\n        result = parse (,) blog \"blog/42/cat-herding-techniques\"\n        -- result == OK (42, \"cat-herding-techniques\")\n    Notice that we use the `(,)` function for building tuples as the first argument\n    to `parse`. The `blog` parser requires a formatter of type `(Int -> String -> a)`\n    so we need to provide that to actually run things.\n    **Note:** The error messages are intended to be fairly helpful. They are\n    nice for debugging during development, but probably too detailed to show\n    directly to users.\n    *)\n    let parse (input:'f) (actuallyParse:Parser<'f,'a>) (url:string) : Result<'a,string> =\n        actuallyParse {seen = []; rest = url.Split '/' |> List.ofArray } input\n        |> function\n           | Error msg ->\n                Error msg\n\n           | Ok ({rest = rest}, result) ->\n                match rest with\n                | [] -> Ok result\n                | [\"\"] -> Ok result\n                | _ ->\n                    Error <| \"The parser worked, but /\" + System.String.Join(\"/\", rest) + \" was left over.\"\n\n\n\n    // PARSE SEGMENTS\n    (* A parser that matches *exactly* the given string. So the following parser\n    will match the URL `/hello/world` and nothing else:\n        helloWorld = s \"hello\" </> s \"world\"\n    *)\n    let s (str : string) : Parser<_,_> =\n        fun {seen = seen;rest = rest} result ->\n            match rest with\n            | [] ->\n                Error (\"Got to the end of the URL but wanted /\" + str)\n\n            | chunk :: remaining ->\n                if chunk = str then\n                    Ok ( {seen=chunk :: seen; rest=remaining}, result )\n                else\n                    Error (\"Wanted /\" + str + \" but got /\" + System.String.Join(\"/\",rest))\n\n\n    (* Create a custom segment parser. The `i32` and `str` parsers are actually\n    defined with it like this:\n        str = custom \"string\" Ok\n        i32 = custom \"NUMBER\" String.toInt\n    The first argument is to help with error messages. It lets us say something\n    like, &ldquo;Got to the end of the URL but wanted /STRING&rdquo; instead of\n    something totally nonspecific. The second argument lets you process the URL\n    segment however you want.\n    An example usage would be a parser that only accepts segments with a particular\n    file extension. So stuff like this:\n        css = custom \"FILE.css\" <| fun str ->\n                if String.endsWith \".css\" str then\n                    Ok str\n                else\n                    Error \"Need something that ends with .css\"\n    *)\n    let custom tipe stringToSomething {seen=seen; rest= rest} fmt =\n        match rest with\n        | [] ->\n            Error (\"Got to the end of the URL but wanted /\" + tipe)\n\n        | chunk :: remaining ->\n            match stringToSomething chunk with\n            | Ok something ->\n                Ok ( {seen = chunk::seen; rest=remaining}, fmt something )\n\n            | Error msg ->\n                Error (\"Parsing `\" + chunk + \"` went wrong: \" + msg)\n\n    (* A parser that matches any string. So the following parser will match\n    URLs like `/search/whatever` where `whatever` can be replaced by any string\n    you can imagine.\n        search = s \"search\" </> str\n    **Note:** this parser will only match URLs with exactly two segments. So things\n    like `/search/this/that` would fail. You could use `search </> str` to handle\n    that case if you wanted though!\n    *)\n    let str chunks = custom \"string\" Ok chunks\n\n\n    (* A parser that matches any integer. So the following parser will match\n    URLs like `/blog/42` where `42` can be replaced by any positive number.\n        blog = s \"blog\" </> i32\n    **Note:** this parser will only match URLs with exactly two segments. So things\n    like `/blog/42/cat-herding-techniques` would fail. You could use `blog </> str`\n    to handle that scenario if you wanted though!\n    *)\n    let i32 chunks = custom \"i32\" (int >> Ok) chunks\n\n\n\n    // COMBINING PARSERS\n\n    (* Combine parsers. It can be used to combine very simple building blocks\n    like this:\n        hello = s \"hello\" </> str\n    So we can say hello to whoever we want. It can also be used to put together\n    arbitrarily complex parsers, so you *could* say something like this too:\n        doubleHello = hello </> hello\n    This would match URLs like `/hello/alice/hello/bob`. The point is more that you\n    can build complex URL parsers in submodules and then put them on the end of\n    parsers in parent modules.\n    *)\n    let (</>) (parseFirst:Parser<'a,'b>) (parseRest:Parser<'b,'c>) : Parser<'a,'c> =\n        fun chunks fmt ->\n            parseFirst chunks fmt\n            |> Result.bind (fun (nextChunks,nextFmt) -> parseRest nextChunks nextFmt)\n\n\n    (* Try a bunch of parsers one at a time. This is useful when there is a known\n    set of branches that are possible. For example, maybe we have a website that\n    just has a blog and a search:\n        type DesiredPage = Blog Int | Search String\n\n        desiredPage = oneOf\n                        [ format Blog (s \"blog\" </> i32)\n                          format Search (s \"search\" </> str) ]\n    The `desiredPage` parser will first try to match things like `/blog/42` and if\n    that fails it will try to match things like `/search/badgers`. It fails if none\n    of the parsers succeed.\n    *)\n    let oneOf (choices:Parser<_,_> list) : Parser<_,_> =\n        let rec oneOfHelp choices chunks formatter =\n            match choices with\n            | [] ->\n                Error \"Tried many parsers, but none of them worked!\"\n\n            | parser :: otherParsers ->\n                match parser chunks formatter with\n                | Error _ ->\n                    oneOfHelp otherParsers chunks formatter\n\n                | Ok answerPair ->\n                    Ok answerPair\n\n        oneOfHelp choices\n\n\n\n    (* Customize an existing parser. Perhaps you want a parser that matches any\n    string, but gives you the result with all lower-case letters:\n        caseInsensitiveString = format String.toLower string\n        -- String.toLower : String -> String\n    I recommend working through how the type variables in `format` would get\n    unified to get a better idea of things, but an intuition of how to use things\n    is probably enough.\n    *)\n    let format input parse chunks fmt =\n        match parse chunks input with\n        | Error msg ->\n            Error msg\n\n        | Ok (newChunks, value) ->\n            Ok (newChunks, fmt value)"]}