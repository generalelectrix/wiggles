{"version":3,"sources":["../../elmish.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcO;AAEC,oCACA;AAAA;AAAE,SADF;;AAIA,sCACA;AAAA,uCAAiC;AAAA;AAAY,aAA7C;AAA8C,SAD9C;;AAIA,kCACO;AAAA,kCAAmB;AAAA;AAAA,6BAAa;AAAA;AAAA;AAAA;AAAA,qBAAb;AAAA;AAAA,aAAnB;AAAgD,SADvD;;AAIA,sCACA;AAAA;AAAA;AAAA;AAAoB,SADpB;;AAKA,0CACI;AACA;AAAA;AAAA,0CACI;AAAA,6CAAqB,uBAAZ,SAAY,CAArB,EACA;AAAA,qCAAgB,8BAEW,wBAFX,GACW,0BAD3B;AAAA;AAEqC,yBAHrC;AAAA,qBADJ;AAAA;AAAA;;AAMJ;AAAA,uBAAS;AAAA;AAAoB,iBAA7B;AAAA;AAPiB,SADjB;;AAYA,wCACI;AACA;AAAA,oBACI;AAAA;AAAA;AAAA;AAC0B,iBAF9B,CAII;AAAA;AAAA;AAAA;AAA0B;AAAA,aAJ9B;;AAKJ;AANgC,SADhC;;AAUA,sCACA;AAAA;AAAK,SADL;;AAMA,8CACI;AAGG;AAFH,yBAEG;AAAA;AAAA;AAAA;AAAA;AAAmC,aAAnC;;AAEP;AALgC,SADhC;;AA/CD;AA+CU,KA/CV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEA;AACU,0CAA+B;AAAA;AAA4C,SAA3E;;AAGT,8CAIA;AAG0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAH1B,6CAIkB;AAAA;AAAA,aAJlB,kBAKY;AAAA;AAAO,aALnB;AAKqB,SATrB;;AAaA,4CAIA;AAAS;AAAA;AAAA,mCAA2B,gBAA3B;AAAA;AAAA;;AACa;AAAA;AAAA;AAAA,uCAAiC,gBAAjC;AAAA;AAAA;AAAA;;AAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAH1B,iDAIkB;AAAA;AAAA,aAJlB,kBAKY;AAAA;AAAO,aALnB;AAKqB,SATrB;;AAaA,4DACA;AAAA;AAAsC,SADtC;;AAIA,4DACI;AACA;AAAA;AAAA;AAAA;AACA;AAAwB,qBADxB;AAAA;AAAA;;AAEoB;AAAxB;AAHwB,SADxB;;AAOA,8CACA;AACmC;AAAA;AAAA;AAAiB;AAAwB,iBAAzC;AAAA;;AADnC;AAC6E,SAF7E;;AAQA,0CACI;AAAc;AACN,qDACR;AACI;AAAA;AAAA,8CACI;AAAA,iDAAW,YAAX,EACA;AAAA,uEACQ;AAAgB;AACpB,wEAAwB;AAAA;AAAO,qCAA/B;AACQ,sDAAsB;AAAA,4CAAI;AAAA;AAAO,yCAAX;AAAW,qCAAjC;AACR,+DAAQ,uBAAR;AAHiB,iCADrB,GAMI;AAAA;AACA,+DAAQ,WAAR;AAAkB,iCAPtB;AAAA,6BADA;AAAA,yBADJ;AAAA;AAAA;;AAWJ;AAAU,aAbF;AAeZ,8CAAuB;AAAA;AAAU,aAAjC;AAES,8BAAsB;AAAA,oBAAI;AAAA;AAAU,iBAAd;AAAc,aAApC,EADT,sEACS;AAlBM,SADf;;AAsBA,kCAAgD;AAAA;AAAkB,SAAlE;;AAvED;AAuEI,KAvEJ","file":"elmish.js","sourcesContent":["namespace Elmish\n\nopen System\n\n/// Dispatch - feed new message into the processing loop\ntype Dispatch<'msg> = 'msg -> unit\n/// Subscriber - return immediately, but may schedule dispatch of a message at any time\ntype Sub<'msg> = 'msg Dispatch -> unit\n/// Cmd - container for subscriptions that may produce messages\ntype Cmd<'msg> = list<'msg Sub>\n\n/// Cmd module creating and manipulating actions\n/// may produce one or more message(s)\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    /// None - no commands, also known as `[]`\n    let none : Cmd<'msg> =\n        []\n\n    /// Command to issue a specific message\n    let ofMsg (msg:'msg) =\n        [fun (dispatch:'msg Dispatch) -> dispatch msg]\n\n    /// When emitting the message, map to another type\n    let map (f:'a -> 'msg) (cmd:Cmd<'a>) : Cmd<'msg> =\n        cmd |> List.map (fun g -> (fun post -> f >> post) >> g)\n\n    /// Aggregate multiple commands\n    let batch (cmds:list<'msg Cmd>) : Cmd<'msg> =\n        List.collect id cmds\n\n    /// Command that will evaluate async block and map the result\n    /// into success or error (of exception)\n    let ofAsync (task:'a->Async<_>) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind dispatch =\n            async {\n                let! r = task arg |> Async.Catch\n                dispatch (match r with\n                         | Choice1Of2 x -> ofSuccess x\n                         | Choice2Of2 x -> ofError x)\n            }\n        [bind >> Async.StartImmediate]\n\n    /// Command to evaluate a simple function and map the result\n    /// into success or error (of exception)\n    let ofFunc (task:'a->_) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind (dispatch:'msg -> unit) =\n            try\n                task arg\n                |> (ofSuccess >> dispatch)\n            with x ->\n                x |> (ofError >> dispatch)\n        [bind]\n\n    /// Command to call the subscriber\n    let ofSub (sub:Sub<'msg>) =\n        [sub]\n\n    open Fable.PowerPack\n\n    /// Command to call `promise` block and map the results\n    let ofPromise (task:'a->Fable.Import.JS.Promise<_>) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind (dispatch:'msg -> unit) =\n            task arg\n            |> Promise.map (ofSuccess >> dispatch)\n            |> Promise.catch (ofError >> dispatch)\n            |> ignore\n        [bind]\n\n\ntype Program<'arg,'model,'msg, 'view> = {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n}\n\n/// Program module - functions to manipulate program instances\nmodule Program =\n    let internal onError (text:string,ex:exn) = Fable.Import.Browser.console.error (text,ex)\n\n    /// Typical program, produces new commands as part of init() and update() as well as the new model.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = onError }\n\n    /// Simple program that produces only new model in init() and update().\n    /// Good for tutorials\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = onError }\n\n    /// Subscribe to external source of events.\n    /// The subscriptions are called once - with the initial model, but can call dispatch whenever they need.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program:Program<'arg,'model,'msg,'view>) =\n        { program with subscribe = subscribe }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program:Program<'arg,'model,'msg,'view>) =\n        let trace text msg model =\n            Fable.Import.Browser.console.log (text, model, msg)\n            program.update msg model\n        { program with update = trace \"Updating:\"}\n\n    /// Trace all the messages as they update the model\n    let withTrace (program:Program<'arg,'model,'msg,'view>) trace =\n        { program\n            with update = fun msg model -> trace msg model; program.update msg model}\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// setState: function that will be called with the new model state and the dispatch function to feed new messages into the loop.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg:'arg) (program:Program<'arg,'model,'msg,'view>) =\n        let (model,cmd) = program.init arg\n        let inbox = MailboxProcessor.Start(fun (mb:MailboxProcessor<'msg>) ->\n            let rec loop (state:'model) =\n                async {\n                    let! msg = mb.Receive()\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' mb.Post\n                        cmd' |> List.iter (fun sub -> sub mb.Post)\n                        return! loop model'\n                    with ex ->\n                        program.onError (\"Unable to process a message:\", ex)\n                        return! loop state\n                }\n            loop model\n        )\n        program.setState model inbox.Post\n        program.subscribe model\n        @ cmd |> List.iter (fun sub -> sub inbox.Post)\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program:Program<unit,'model,'msg,'view>) = runWith () program\n\n"]}