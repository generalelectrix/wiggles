import _typeof from "babel-runtime/helpers/typeof";
import _classCallCheck from "babel-runtime/helpers/classCallCheck";
import _createClass from "babel-runtime/helpers/createClass";
import { setType } from "fable-core/Symbol";
import _Symbol from "fable-core/Symbol";
import { compareRecords, equalsRecords, makeGeneric } from "fable-core/Util";
import { ofArray } from "fable-core/List";
import List from "fable-core/List";
import { ResultModule, Result } from "./result";
import { split, join } from "fable-core/String";
export var Chunks = function () {
    function Chunks(seen, rest) {
        _classCallCheck(this, Chunks);

        this.seen = seen;
        this.rest = rest;
    }

    _createClass(Chunks, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "Elmish.UrlParser.Chunks",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    seen: makeGeneric(List, {
                        T: "string"
                    }),
                    rest: makeGeneric(List, {
                        T: "string"
                    })
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Chunks;
}();
setType("Elmish.UrlParser.Chunks", Chunks);
export function parse(input, actuallyParse, url) {
    return function (_arg1) {
        if (_arg1.Case === "Ok") {
            var _ret = function () {
                var result = _arg1.Fields[0][1];
                var rest = _arg1.Fields[0][0].rest;

                var _target2 = function _target2() {
                    return new Result("Error", ["The parser worked, but /" + join("/", rest) + " was left over."]);
                };

                if (rest.tail != null) {
                    if (rest.head === "") {
                        if (rest.tail.tail == null) {
                            return {
                                v: new Result("Ok", [result])
                            };
                        } else {
                            return {
                                v: _target2()
                            };
                        }
                    } else {
                        return {
                            v: _target2()
                        };
                    }
                } else {
                    return {
                        v: new Result("Ok", [result])
                    };
                }
            }();

            if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        } else {
            return new Result("Error", [_arg1.Fields[0]]);
        }
    }(actuallyParse(new Chunks(new List(), ofArray(split(url, "/"))))(input));
}
export function s(str, _arg1, result) {
    if (_arg1.rest.tail != null) {
        if (_arg1.rest.head === str) {
            return new Result("Ok", [[new Chunks(new List(_arg1.rest.head, _arg1.seen), _arg1.rest.tail), result]]);
        } else {
            return new Result("Error", ["Wanted /" + str + " but got /" + join("/", _arg1.rest)]);
        }
    } else {
        return new Result("Error", ["Got to the end of the URL but wanted /" + str]);
    }
}
export function custom(tipe, stringToSomething, _arg1, fmt) {
    if (_arg1.rest.tail != null) {
        var matchValue = stringToSomething(_arg1.rest.head);

        if (matchValue.Case === "Error") {
            return new Result("Error", ["Parsing `" + _arg1.rest.head + "` went wrong: " + matchValue.Fields[0]]);
        } else {
            return new Result("Ok", [[new Chunks(new List(_arg1.rest.head, _arg1.seen), _arg1.rest.tail), fmt(matchValue.Fields[0])]]);
        }
    } else {
        return new Result("Error", ["Got to the end of the URL but wanted /" + tipe]);
    }
}
export function str(chunks) {
    var tipe = "string";

    var stringToSomething = function stringToSomething(arg0) {
        return new Result("Ok", [arg0]);
    };

    return function (fmt) {
        return custom(tipe, stringToSomething, chunks, fmt);
    };
}
export function i32(chunks) {
    var tipe = "i32";

    var stringToSomething = function stringToSomething($var13) {
        return new Result("Ok", [$var13]);
    };

    return function (fmt) {
        return custom(tipe, stringToSomething, chunks, fmt);
    };
}
export function op_LessDivideGreater(parseFirst, parseRest, chunks, fmt) {
    return ResultModule.bind(function (tupledArg) {
        return parseRest(tupledArg[0])(tupledArg[1]);
    }, parseFirst(chunks)(fmt));
}
export function oneOf(choices) {
    var oneOfHelp = function oneOfHelp(choices_1) {
        return function (chunks) {
            return function (formatter) {
                if (choices_1.tail != null) {
                    var matchValue = choices_1.head(chunks)(formatter);

                    if (matchValue.Case === "Ok") {
                        return new Result("Ok", [matchValue.Fields[0]]);
                    } else {
                        return oneOfHelp(choices_1.tail)(chunks)(formatter);
                    }
                } else {
                    return new Result("Error", ["Tried many parsers, but none of them worked!"]);
                }
            };
        };
    };

    return oneOfHelp(choices);
}
export function format(input, parse_1, chunks, fmt) {
    var matchValue = parse_1(chunks)(input);

    if (matchValue.Case === "Ok") {
        var value = matchValue.Fields[0][1];
        var newChunks = matchValue.Fields[0][0];
        return new Result("Ok", [[newChunks, fmt(value)]]);
    } else {
        return new Result("Error", [matchValue.Fields[0]]);
    }
}
//# sourceMappingURL=parser.js.map