{"version":3,"sources":["../elmish.fs"],"names":[],"mappings":";;;;;;;;;;AAcO;AAEC,gCACA;AAAA;AAAE,KADF;;AAIA,kCACA;AAAA,wBAAiC;AAAA;AAAY,SAA7C;AAA8C,KAD9C;;AAIA,8BACO;AAAA,qBAAmB;AAAA;AAAA,yBAAa;AAAA;AAAA;AAAA;AAAA,iBAAb;AAAA;AAAA,SAAnB;AAAgD,KADvD;;AAIA,kCACA;AAAA;AAAA;AAAA;AAAoB,KADpB;;AAKA,sCACI;AACA;AAAA;AAAA,sCACI;AAAA,yCAAqB,WAAZ,SAAY,CAArB,EACA;AAAA,iCAAgB,8BAEW,wBAFX,GACW,0BAD3B;AAAA;AAEqC,qBAHrC;AAAA,iBADJ;AAAA;AAAA;;AAMJ;AAAA,mBAAS;AAAA;AAAoB,aAA7B;AAAA;AAPiB,KADjB;;AAYA,oCACI;AACA;AAAA,gBACI;AAAA;AAAA;AAAA;AAC0B,aAF9B,CAII;AAAA;AAAA;AAAA;AAA0B;AAAA,SAJ9B;;AAKJ;AANgC,KADhC;;AAUA,kCACA;AAAA;AAAK,KADL;;AAMA,0CACI;AAGG;AAFH,qBAEG;AAAA;AAAA;AAAA;AAAA;AAAmC,SAAnC;;AAEP;AALgC,KADhC;;AA/CD;AA+CU,CA/CV;AAwDF;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAUE;AACU,sCAA+B;AAAA;AAA4C,KAA3E;;AAGT,0CAIA;AAG0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAH1B,yCAIkB;AAAA;AAAA,SAJlB,kBAKY;AAAA;AAAO,SALnB;AAKqB,KATrB;;AAaA,wCAIA;AAAS;AAAA;AAAA,+BAA2B,gBAA3B;AAAA;AAAA;;AACa;AAAA;AAAA;AAAA,mCAAiC,gBAAjC;AAAA;AAAA;AAAA;;AAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAH1B,6CAIkB;AAAA;AAAA,SAJlB,kBAKY;AAAA;AAAO,SALnB;AAKqB,KATrB;;AAaA,wDACA;AAAA;AAAsC,KADtC;;AAIA,wDACI;AACA;AAAA;AAAA;AAAA;AACA;AAAwB,iBADxB;AAAA;AAAA;;AAEoB;AAAxB;AAHwB,KADxB;;AAOA,0CACA;AACmC;AAAA;AAAA;AAAiB;AAAwB,aAAzC;AAAA;;AADnC;AAC6E,KAF7E;;AAQA,sCACI;AAAc;AACN,0BACR;AACI;AAAA;AAAA,0CACI;AAAA,6CAAW,YAAX,EACA;AAAA,mEACQ;AAAgB;AACpB,oEAAwB;AAAA;AAAO,iCAA/B;AACQ,wCAAsB;AAAA,wCAAI;AAAA;AAAO,qCAAX;AAAW,iCAAjC;AACR,2DAAQ,uBAAR;AAHiB,6BADrB,GAMI;AAAA;AACA,2DAAQ,WAAR;AAAkB,6BAPtB;AAAA,yBADA;AAAA,qBADJ;AAAA;AAAA;;AAWJ;AAAU,SAbF;AAeZ,0CAAuB;AAAA;AAAU,SAAjC;AAES,gBAAsB;AAAA,gBAAI;AAAA;AAAU,aAAd;AAAc,SAApC,EADT,2DACS;AAlBM,KADf;;AAsBA,8BAAgD;AAAA;AAAkB,KAAlE;;AAvED;AAuEI,CAvEJ","file":"elmish.js","sourcesContent":["namespace Elmish\n\nopen System\n\n/// Dispatch - feed new message into the processing loop\ntype Dispatch<'msg> = 'msg -> unit\n/// Subscriber - return immediately, but may schedule dispatch of a message at any time\ntype Sub<'msg> = 'msg Dispatch -> unit\n/// Cmd - container for subscriptions that may produce messages\ntype Cmd<'msg> = list<'msg Sub>\n\n/// Cmd module creating and manipulating actions\n/// may produce one or more message(s)\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    /// None - no commands, also known as `[]`\n    let none : Cmd<'msg> =\n        []\n\n    /// Command to issue a specific message\n    let ofMsg (msg:'msg) =\n        [fun (dispatch:'msg Dispatch) -> dispatch msg]\n\n    /// When emitting the message, map to another type\n    let map (f:'a -> 'msg) (cmd:Cmd<'a>) : Cmd<'msg> =\n        cmd |> List.map (fun g -> (fun post -> f >> post) >> g)\n\n    /// Aggregate multiple commands\n    let batch (cmds:list<'msg Cmd>) : Cmd<'msg> =\n        List.collect id cmds\n\n    /// Command that will evaluate async block and map the result\n    /// into success or error (of exception)\n    let ofAsync (task:'a->Async<_>) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind dispatch =\n            async {\n                let! r = task arg |> Async.Catch\n                dispatch (match r with\n                         | Choice1Of2 x -> ofSuccess x\n                         | Choice2Of2 x -> ofError x)\n            }\n        [bind >> Async.StartImmediate]\n\n    /// Command to evaluate a simple function and map the result\n    /// into success or error (of exception)\n    let ofFunc (task:'a->_) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind (dispatch:'msg -> unit) =\n            try\n                task arg\n                |> (ofSuccess >> dispatch)\n            with x ->\n                x |> (ofError >> dispatch)\n        [bind]\n\n    /// Command to call the subscriber\n    let ofSub (sub:Sub<'msg>) =\n        [sub]\n\n    open Fable.PowerPack\n\n    /// Command to call `promise` block and map the results\n    let ofPromise (task:'a->Fable.Import.JS.Promise<_>) (arg:'a) (ofSuccess:_->'msg) (ofError:_->'msg) : Cmd<'msg> =\n        let bind (dispatch:'msg -> unit) =\n            task arg\n            |> Promise.map (ofSuccess >> dispatch)\n            |> Promise.catch (ofError >> dispatch)\n            |> ignore\n        [bind]\n\n\ntype Program<'arg,'model,'msg, 'view> = {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n}\n\n/// Program module - functions to manipulate program instances\nmodule Program =\n    let internal onError (text:string,ex:exn) = Fable.Import.Browser.console.error (text,ex)\n\n    /// Typical program, produces new commands as part of init() and update() as well as the new model.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = onError }\n\n    /// Simple program that produces only new model in init() and update().\n    /// Good for tutorials\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = onError }\n\n    /// Subscribe to external source of events.\n    /// The subscriptions are called once - with the initial model, but can call dispatch whenever they need.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program:Program<'arg,'model,'msg,'view>) =\n        { program with subscribe = subscribe }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program:Program<'arg,'model,'msg,'view>) =\n        let trace text msg model =\n            Fable.Import.Browser.console.log (text, model, msg)\n            program.update msg model\n        { program with update = trace \"Updating:\"}\n\n    /// Trace all the messages as they update the model\n    let withTrace (program:Program<'arg,'model,'msg,'view>) trace =\n        { program\n            with update = fun msg model -> trace msg model; program.update msg model}\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// setState: function that will be called with the new model state and the dispatch function to feed new messages into the loop.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg:'arg) (program:Program<'arg,'model,'msg,'view>) =\n        let (model,cmd) = program.init arg\n        let inbox = MailboxProcessor.Start(fun (mb:MailboxProcessor<'msg>) ->\n            let rec loop (state:'model) =\n                async {\n                    let! msg = mb.Receive()\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' mb.Post\n                        cmd' |> List.iter (fun sub -> sub mb.Post)\n                        return! loop model'\n                    with ex ->\n                        program.onError (\"Unable to process a message:\", ex)\n                        return! loop state\n                }\n            loop model\n        )\n        program.setState model inbox.Post\n        program.subscribe model\n        @ cmd |> List.iter (fun sub -> sub inbox.Post)\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program:Program<unit,'model,'msg,'view>) = runWith () program\n\n"]}