{"version":3,"sources":["../../browser-nav.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcO;AAAA;;AAEC,8CACA;AAAA,uCAAK;AAAA;AAAC,aAAN;AAA+C,SAD/C;;AAGA,wCACA;AAAA,uCAAK;AAAK;AACS;AACT,iEAAgD,EAAhD;AACA;AAHJ,aAAN;AAIqB,SALrB;;AAOA,oCACA;AAAA,uCAAK;AAAA;AAAC,aAAN;AAAuB,SADvB;;AAZD;AAYK,KAZL;;AAeA;AAGD,kDAGE;AAAA;AAAA,sCACc,sBAAQ;AAAA;AAAA,iBAAR,eADd;AAAA;;AAIA;AAAA;AAAA,+BAAM,yBAIF,oCAJE,GAEF,UAAW,qBAAX,QAFJ;AAAA;AAAA;;AAQY;AAAA;;AAEF;AAAA;AAGF;AAAA;AACA;AAAkC,yBADlC;;AAHE;AAAA,gCACW;AAAA;AAAA;AAA2B,6BAA3B,EADX,EACW;AAAA;AAAA;AAA2B,6BADtC,MACW;AAAA;AAA2B;AAD1B,yBAAZ;AAAA;AAAY;AAAA,qBAAZ;AAAA;;AAFE;AAAA;AAWZ;AAXwB,aAAZ;;AAcZ;AAAA,+CACE,oBAAE,qCAAF,EAC6B,sBAAQ;AAAA;AAAA,iBAAR,EAA3B,wBAA2B,CAD7B,EADF;AAAA;;AAKA;AAAA,wCAAc,uBAAd;AAAA;;AAM+B;AAAA;AAAA;AAAA,wCAAwB;AAAA;AAAA,yBAAxB;AAAA;AAA4C,iBAA5C;AAAA;;AAJnC,2DAK+B;AAAA;AAAA;AAAA,wCAAoB;AAAA;AAAA,yBAApB;AAAA;AAAA;AAAA,aAL/B;AAjCoB,SAHlB;;AAHC;AAGU,KAHV","file":"browser-nav.js","sourcesContent":["/// This library is primarily about treating the address bar as an input to your program. \nnamespace Elmish.Browser.Navigation\n\nopen Fable.Import.Browser\nopen Elmish\n\n/// Parser is a function to turn the string in the address bar into\n/// data that is easier for your app to handle.\ntype Parser<'a> = Location -> 'a\n\ntype Navigable<'msg> = \n    | Change of Location\n    | UserMsg of 'msg\n\nmodule Navigation =\n    let [<Literal>] internal NavigatedEvent = \"NavigatedEvent\"\n    let modifyUrl (newUrl:string) =\n        [fun _ -> history.replaceState((), \"\", newUrl)]\n\n    let newUrl (newUrl:string) =\n        [fun _ -> history.pushState((), \"\", newUrl)\n                  let ev = document.createEvent_CustomEvent()\n                  ev.initCustomEvent (NavigatedEvent, true, true, obj())\n                  window.dispatchEvent ev\n                  |> ignore ]\n\n    let jump (n:int) =\n        [fun _ -> history.go n]\n\nmodule Program =\n  /// Add the navigation to a program made with `mkProgram` or `mkSimple`.\n  /// urlUpdate: similar to `update` function, but receives parsed url instead of message as an input.\n  let toNavigable (parser : Parser<'a>) \n                  (urlUpdate : 'a->'model->('model * Cmd<'msg>)) \n                  (program : Program<'a,'model,'msg,'view>) =\n    let map (model, cmd) = \n        model, cmd |> Cmd.map UserMsg\n    \n    let update msg model =\n        match msg with\n        | Change location ->\n            urlUpdate (parser location) model\n        | UserMsg userMsg ->\n            program.update userMsg model\n        |> map\n\n    let locationChanges (dispatch:Dispatch<_ Navigable>) = \n        let mutable lastLocation = None\n        let onChange _ =\n            match lastLocation with\n            | Some href when href = window.location.href -> ()\n            | _ ->\n                lastLocation <- Some window.location.href\n                Change window.location |> dispatch\n            |> box\n                \n        window.addEventListener_popstate(unbox onChange)\n        window.addEventListener_hashchange(unbox onChange)\n        window.addEventListener(Navigation.NavigatedEvent, unbox onChange)\n    \n    let subs model =\n        Cmd.batch\n          [ [locationChanges]\n            program.subscribe model |> Cmd.map UserMsg ]\n    \n    let init () = \n        program.init (parser window.location) |> map\n    \n    { init = init \n      update = update\n      subscribe = subs\n      onError = program.onError\n      setState = fun model dispatch -> program.setState model (UserMsg >> dispatch) \n      view = fun model dispatch -> program.view model (UserMsg >> dispatch) }\n    \n    \n\n"]}