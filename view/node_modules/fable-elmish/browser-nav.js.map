{"version":3,"sources":["../browser-nav.fs"],"names":[],"mappings":";;;;;;;AAUK;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIE;AAAA;;AAEC,0CACA;AAAA,wBAAK;AAAA;AAAC,SAAN;AAA+C,KAD/C;;AAGA,oCACA;AAAA,wBAAK;AAAK;AACS;AACT,6DAAgD,EAAhD;AACA;AAHJ,SAAN;AAIqB,KALrB;;AAOA,gCACA;AAAA,wBAAK;AAAA;AAAC,SAAN;AAAuB,KADvB;;AAZD;AAYK,CAZL;AAeA;AAGD,8CAGE;AAAA;AAAA,kCACc,cAAQ;AAAA;AAAA,aAAR,eADd;AAAA;;AAIA;AAAA;AAAA,2BAAM,yBAIF,oCAJE,GAEF,UAAW,qBAAX,QAFJ;AAAA;AAAA;;AAQY;AAAA;;AAEF;AAAA;AAGF;AAAA;AACA;AAAkC,qBADlC;;AAHE;AAAA,4BACW;AAAA;AAAA;AAA2B,yBAA3B,EADX,EACW;AAAA;AAAA;AAA2B,yBADtC,MACW;AAAA;AAA2B;AAD1B,qBAAZ;AAAA;AAAY;AAAA,iBAAZ;AAAA;;AAFE;AAAA;AAWZ;AAXwB,SAAZ;;AAcZ;AAAA,mCACE,SAAE,0BAAF,EAC6B,cAAQ;AAAA;AAAA,aAAR,EAA3B,wBAA2B,CAD7B,EADF;AAAA;;AAKA;AAAA,oCAAc,uBAAd;AAAA;;AAM+B;AAAA;AAAA;AAAA,oCAAwB;AAAA;AAAA,qBAAxB;AAAA;AAA4C,aAA5C;AAAA;;AAJnC,iDAK+B;AAAA;AAAA;AAAA,oCAAoB;AAAA;AAAA,qBAApB;AAAA;AAAA;AAAA,SAL/B;AAjCoB,KAHlB;;AAHC;AAGU,CAHV","file":"browser-nav.js","sourcesContent":["/// This library is primarily about treating the address bar as an input to your program. \nnamespace Elmish.Browser.Navigation\n\nopen Fable.Import.Browser\nopen Elmish\n\n/// Parser is a function to turn the string in the address bar into\n/// data that is easier for your app to handle.\ntype Parser<'a> = Location -> 'a\n\ntype Navigable<'msg> = \n    | Change of Location\n    | UserMsg of 'msg\n\nmodule Navigation =\n    let [<Literal>] internal NavigatedEvent = \"NavigatedEvent\"\n    let modifyUrl (newUrl:string) =\n        [fun _ -> history.replaceState((), \"\", newUrl)]\n\n    let newUrl (newUrl:string) =\n        [fun _ -> history.pushState((), \"\", newUrl)\n                  let ev = document.createEvent_CustomEvent()\n                  ev.initCustomEvent (NavigatedEvent, true, true, obj())\n                  window.dispatchEvent ev\n                  |> ignore ]\n\n    let jump (n:int) =\n        [fun _ -> history.go n]\n\nmodule Program =\n  /// Add the navigation to a program made with `mkProgram` or `mkSimple`.\n  /// urlUpdate: similar to `update` function, but receives parsed url instead of message as an input.\n  let toNavigable (parser : Parser<'a>) \n                  (urlUpdate : 'a->'model->('model * Cmd<'msg>)) \n                  (program : Program<'a,'model,'msg,'view>) =\n    let map (model, cmd) = \n        model, cmd |> Cmd.map UserMsg\n    \n    let update msg model =\n        match msg with\n        | Change location ->\n            urlUpdate (parser location) model\n        | UserMsg userMsg ->\n            program.update userMsg model\n        |> map\n\n    let locationChanges (dispatch:Dispatch<_ Navigable>) = \n        let mutable lastLocation = None\n        let onChange _ =\n            match lastLocation with\n            | Some href when href = window.location.href -> ()\n            | _ ->\n                lastLocation <- Some window.location.href\n                Change window.location |> dispatch\n            |> box\n                \n        window.addEventListener_popstate(unbox onChange)\n        window.addEventListener_hashchange(unbox onChange)\n        window.addEventListener(Navigation.NavigatedEvent, unbox onChange)\n    \n    let subs model =\n        Cmd.batch\n          [ [locationChanges]\n            program.subscribe model |> Cmd.map UserMsg ]\n    \n    let init () = \n        program.init (parser window.location) |> map\n    \n    { init = init \n      update = update\n      subscribe = subs\n      onError = program.onError\n      setState = fun model dispatch -> program.setState model (UserMsg >> dispatch) \n      view = fun model dispatch -> program.view model (UserMsg >> dispatch) }\n    \n    \n\n"]}